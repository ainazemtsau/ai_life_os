---
description: Execute the tasks of a single module in strict TDD order, touching only its allowed_dirs. Produce code, tests, and docs-sync required to reach the module’s Definition of Done.
---

User input:

$ARGUMENTS
# Expected: MODULE=<module-id> [DRY_RUN=1]

Goal
- Implement exactly one module to READY state (per-module DoD) without crossing boundaries.
- Respect Contracts-First: tests before implementation, public surface stability, SemVer rules.

Preconditions
- `specs/<feature>/plan.md` exists (run /plan before this).
- `specs/<feature>/tasks.by-module/<MODULE>.md` exists (generated by /tasks or /fanout-tasks).
- `.specify/memory/public/registry.yaml` is valid.

Steps

1) Parse arguments
   - Extract `MODULE` (required). If missing → ERROR "MODULE is required".
   - Optional `DRY_RUN=1` to print planned actions without writing files.

2) Resolve context (once)
   - Run `.specify/scripts/bash/setup-plan.sh --json` to get { FEATURE_SPEC, SPECS_DIR, BRANCH }.
   - Load `.specify/memory/public/registry.yaml`, find entry for MODULE:
     * `allowed_dirs`, `manifest`, `contract`, `import_hint`, `semver`, `uses`.
   - Load module playbook: `specs/<feature>/tasks.by-module/<MODULE>.md`.

3) Enforce boundaries
   - All file writes MUST be inside `allowed_dirs` for MODULE.
   - If a task requires edits outside → create/append `specs/<feature>/handoff.md` with a CDC request and STOP that subtask.

4) Execute Tasks (strict TDD order)
   A. **Contract tests** (should fail first)
      - Create/extend tests under module’s test dirs (`backend/tests/<module>/...` or `frontend/...`) according to playbook.
      - If HTTP provider: add contract tests for OpenAPI schema, and CDC tests if there is a known consumer.
      - If in-process port: add unit tests against the public exports.

   B. **Domain/DTO/Port or API Schema**
      - Implement minimal domain types/DTOs/ports to satisfy failing tests OR author the API schema draft (no implementation yet).
      - Keep functions small; no deep imports from other modules.

   C. **Implementation**
      - Repositories/services/components/hooks per playbook.
      - Follow KISS, SOLID; avoid duplication; extract constants; keep cyclomatic complexity low.

   D. **API / Client wiring**
      - Backend: implement FastAPI routes (if HTTP module).
      - Frontend: implement API client/hooks/components against contracts.

   E. **Integration checks**
      - Wire via `import_hint` (in-process) or HTTP client.
      - Ensure no cross-module source reads.

   F. **Docs sync**
      - Update module manifest (`*.api.md`): Exports/Types/Usage/Changelog.
      - If public surface changed:
        * Bump SemVer: MAJOR (breaking) | MINOR (additive) | PATCH (fix).
        * Note change in manifest and prepare Conventional Commit with `[public-api]`.

5) Keepers of quality (local)
   - Use the project's Makefile `qa` target for quality checks:
     * For backend modules: `cd backend && make qa`
     * For frontend modules: `cd frontend && make qa`
   - The `make qa` command runs:
     * Format + lint fixes + lint check
     * Type checking (mypy/tsc)
     * Tests (pytest/vitest)
     * Coverage reports (for backend)
   - This ensures consistent quality checks across all modules.

6) Contracts (if applicable)
   - HTTP: ensure `backend/scripts/export_openapi.py` (or equivalent) regenerates the spec into `contract` path from registry.
     * Example:
       ```
       python backend/scripts/export_openapi.py
       npx @redocly/cli lint backend/src/ai_life_backend/contracts/<module>_openapi.yaml
       ```
   - In-process port: ensure exported names match the manifest’s “Exports” list (use `.specify/scripts/manifest_lint.py` if available).

7) Output
   - Print a concise summary:
     * files created/updated (within allowed_dirs),
     * tests added/updated,
     * whether public surface changed and SemVer bump proposal,
     * any handoff items created.

8) Exit semantics
   - If any step requires cross-module changes → STOP that subtask and record it in `handoff.md`.
   - Do not mark the module READY; verification is done by `/module-verify`.

Behavior constraints
- Never edit files outside MODULE’s `allowed_dirs`.
- Never deep-import other module internals; use `import_hint` or HTTP only.
- Keep changes minimal and test-driven; no speculative features.
- Prefer small, composable functions (≤40 lines) and clear types.

Suggested next command
- `/module-verify MODULE=<MODULE>`
