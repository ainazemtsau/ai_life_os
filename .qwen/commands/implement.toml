# Qwen Code custom command: /implement
# Usage from chat: /implement MODULE=<module-id> [FEATURE=<feature-id>]
# Example: /implement MODULE=frontend.design FEATURE=001-two-mods

name = "implement"
description = "Execute implementation for a single module using per-module tasks with Registry-enforced boundaries."

# Qwen will append user-supplied arguments to {{input}}. Pass: MODULE=<id> [FEATURE=<id>]
prompt = """
You are the code assistant executing **modular implementation** for a single module under the Spec Kit workflow.
You MUST strictly follow the constraints and never read or modify sources of other modules. Use only Public API manifests & language contracts.

User input (parse this first!):
{{input}}

========================
PROJECT LAYOUT (assume repo root)
- Features:            specs/<FEATURE>/
- Global tasks:        specs/<FEATURE>/tasks.md
- Per-module tasks:    specs/<FEATURE>/tasks.by-module/<MODULE>-tasks.md
- Handoff file:        specs/<FEATURE>/handoff.md         (create if missing)
- Constitutions:
  - Global:            .specify/memory/constitution.md
  - Module-local:      .specify/memory/<MODULE>.constitution.md  (optional)
- Public API Registry: .specify/memory/public/registry.yaml
- Validators:
  - python .specify/scripts/registry_validate.py
  - python .specify/scripts/manifest_lint.py

========================
ARGUMENTS & DISCOVERY
1) Parse args from {{input}}:
   - REQUIRED: MODULE=<module-id>   (e.g., backend.repo / frontend.design)
   - OPTIONAL: FEATURE=<feature-id> (e.g., 003-goals-agents-mvp)
2) If FEATURE is not provided:
   - Search for exactly one match: specs/*/tasks.by-module/<MODULE>-tasks.md
   - If none or multiple matches → STOP and ask user to specify FEATURE explicitly.
3) Compute absolute paths for:
   FEATURE_DIR, GLOBAL_TASKS, MODULE_TASKS, PLAN, HANDOFF, CONST_GLOBAL, CONST_MODULE, REGISTRY.
   REQUIRE: plan.md and <MODULE>-tasks.md must exist; otherwise STOP and instruct to run /plan or /module-tasks.

========================
REGISTRY-DRIVEN CONTEXT (NO DEEP INSPECTION)
4) Read .specify/memory/public/registry.yaml and locate <MODULE> entry.
   Extract: import_hint, uses[], manifest, contract, semver.
5) For each module listed in <MODULE>.uses:
   - Load ONLY its manifest and contract files.
   - DO NOT open or scan their source code directories.
6) Load constitutions (global + module-local) and enforce Clean Code rules strictly (SOLID, no magic values, small functions/files, DRY, KISS).

========================
TASK EXECUTION (TDD-first, boundaries enforced)
7) Parse specs/<FEATURE>/tasks.by-module/<MODULE>-tasks.md:
   - Identify phases (Setup → Tests → Implementation → Integration → Polish → Docs sync).
   - Identify task IDs, [P] markers, explicit file paths, dependencies.
   - VERIFY that ALL task paths are INSIDE <MODULE>. If any path escapes → STOP and request tasks fix.
8) Execute by phases:
   - Tests must be authored to FAIL before implementation (TDD).
   - [P] tasks: run in parallel only if touching different files and with no dependencies.
   - Same-file tasks are sequential.
   - After a task truly passes (tests/linters), mark [x] in the module tasks file and commit a focused change.

========================
PUBLIC API DOCS SYNC (MANDATORY GATE)
9) If public exports for <MODULE> were added/changed/removed:
   - Update MANIFEST (.specify/memory/public/*.api.md): sections Exports/Types/Usage and **Version: x.y.z**.
   - Update CONTRACT (.d.ts / Protocol.py) accordingly.
   - Apply SemVer:
     * additive (backward-compatible) → MINOR
     * breaking change → MAJOR
     * doc-only/bugfix → PATCH
10) Run validators (must PASS; otherwise STOP with clear error):
    - python .specify/scripts/registry_validate.py
    - python .specify/scripts/manifest_lint.py

========================
HANDOFF INSTEAD OF CROSS-MODULE EDITS
11) If <MODULE> needs a change in another module:
    - Append an entry to specs/<FEATURE>/handoff.md:
      from: <MODULE>
      to:   <target-module-id>
      reason: <why>
      required change: <describe manifest+contract addition/change needed>
      blocking: yes|no
    - STOP editing foreign modules. Wait for the owner module to extend its public API.

========================
SAFETY RAILS (DO NOT BREAK)
- Never read or modify files outside <MODULE>.
- Never import from other modules except exactly as stated in their import_hint.
- Do NOT guess missing paths; per-module tasks must contain explicit file paths.
- Enforce Clean Code from constitution: SOLID, no magic values, short functions/files, DRY, KISS.
- If FEATURE or MODULE cannot be uniquely resolved, STOP and request precise args.

========================
COMPLETION REPORT
12) When done, output a concise summary:
   - Completed task IDs
   - Files created/modified
   - Any API/manifest/contract updates + new SemVer
   - Validators status
   - Any HANDOFF entries added

NOTE:
- If module tasks do not exist yet, instruct to run /fanout-tasks <FEATURE> then /module-tasks <FEATURE> <MODULE>.
- Dependencies are opaque: ONLY use their MANIFEST + CONTRACT; do not open their sources.
"""
